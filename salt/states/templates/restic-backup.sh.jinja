#!/bin/bash
set -euo pipefail

HOST_ID="$(hostname -f 2>/dev/null || hostname)"
EVENT_STATUS="success"
EVENT_RC=0
LOG_FILE=""

emit_salt_event() {
    local tag="$1"
    shift || true

    local PYTHON_BIN="/opt/saltstack/salt/bin/python3"
    if [[ ! -x "$PYTHON_BIN" ]]; then
        PYTHON_BIN="python3"
    fi

    if ! command -v "$PYTHON_BIN" >/dev/null 2>&1; then
        return 0
    fi

    if "$PYTHON_BIN" - "$tag" "$@" <<'PY'
import sys
try:
    from salt.client import Caller
except Exception:
    sys.exit(1)

tag = sys.argv[1]
data = {}
for arg in sys.argv[2:]:
    if '=' not in arg:
        continue
    key, value = arg.split('=', 1)
    data[key] = value

try:
    caller = Caller()
except Exception:
    sys.exit(1)

try:
    caller.cmd('event.send', tag, data)
except Exception:
    sys.exit(1)
else:
    sys.exit(0)
PY
    then
        return 0
    fi

    if command -v salt-call >/dev/null 2>&1; then
        salt-call event.send "$tag" "$@" >/dev/null 2>&1 || true
    fi
}

emit_restic_event() {
    local status="$EVENT_STATUS"
    local suffix="success"
    if [[ "$status" != "success" ]]; then
        suffix="failure"
    fi

    emit_salt_event "saltgoat/backup/restic/${suffix}" \
        "id=$HOST_ID" \
        "host=$HOST_ID" \
        "origin=timer" \
        "repo=${RESTIC_REPOSITORY:-unknown}" \
        "log_file=${LOG_FILE:-}" \
        "return_code=$EVENT_RC"
}

on_error() {
    EVENT_RC=$?
    EVENT_STATUS="failure"
}

trap on_error ERR
trap emit_restic_event EXIT

ENV_FILE="{{ env_file }}"
if [[ -f "$ENV_FILE" ]]; then
    set -a
    # shellcheck disable=SC1090
    source "$ENV_FILE"
    set +a
else
    echo "[restic] env file not found: $ENV_FILE" >&2
    exit 1
fi

RESTIC_BIN="${RESTIC_BIN:-restic}"
INCLUDE_FILE="${RESTIC_INCLUDE_FILE:-{{ include_file }}}"
EXCLUDE_FILE="${RESTIC_EXCLUDE_FILE:-{{ exclude_file }}}"
LOG_DIR="${RESTIC_LOG_DIR:-{{ log_dir }}}"
mkdir -p "$LOG_DIR"
TS="$(date +%Y%m%d_%H%M%S)"
LOG_FILE="$LOG_DIR/backup-${TS}.log"

exec >> >(tee -a "$LOG_FILE") 2>&1

echo "[restic] manual backup started at ${TS}"

TMP_ENV="$(mktemp)"
cat >"$TMP_ENV" <<EOF
#!/bin/bash
set -euo pipefail
export RESTIC_PASSWORD="${RESTIC_PASSWORD:-}"
export RESTIC_PASSWORD_FILE="${RESTIC_PASSWORD_FILE:-}"
export RESTIC_BIN="$RESTIC_BIN"
export RESTIC_REPOSITORY="${RESTIC_REPOSITORY:-}"
export RESTIC_CACHE_DIR="${RESTIC_CACHE_DIR:-}"
export RESTIC_TAGS="${RESTIC_TAGS:-}"
export RESTIC_BACKUP_ARGS="${RESTIC_BACKUP_ARGS:-}"
export RESTIC_FORGET_ARGS="${RESTIC_FORGET_ARGS:-}"
export RESTIC_CHECK_AFTER_BACKUP="${RESTIC_CHECK_AFTER_BACKUP:-0}"
export RESTIC_INCLUDE_FILE="$INCLUDE_FILE"
export RESTIC_EXCLUDE_FILE="$EXCLUDE_FILE"
EOF

for key in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_DEFAULT_REGION; do
    eval "value=\"\${$key:-}\""
    if [[ -n "$value" ]]; then
        printf 'export %s=%q\n' "$key" "$value" >>"$TMP_ENV"
    fi
done

chmod 600 "$TMP_ENV"

cleanup=("$TMP_ENV")
if [[ -n "${RESTIC_PASSWORD:-}" ]]; then
    unset RESTIC_PASSWORD
fi

if [[ -n "${RESTIC_PASSWORD_FILE:-}" && -f "${RESTIC_PASSWORD_FILE}" ]]; then
    chmod 600 "${RESTIC_PASSWORD_FILE}"
fi

if [[ -n "$RESTIC_REPO_OWNER" ]]; then
    chown -R "$RESTIC_REPO_OWNER":"$RESTIC_REPO_OWNER" "${RESTIC_REPOSITORY%:*}" 2>/dev/null || true
fi

/bin/bash "$TMP_ENV" <<'EOS'
set -euo pipefail
source "$1"

RESTIC_ARGS=("--files-from=$RESTIC_INCLUDE_FILE")
if [[ -s "$RESTIC_EXCLUDE_FILE" ]]; then
    RESTIC_ARGS+=("--exclude-file=$RESTIC_EXCLUDE_FILE")
fi
if [[ -n "$RESTIC_BACKUP_ARGS" ]]; then
    # shellcheck disable=SC2206
    EXTRA_ARGS=( $RESTIC_BACKUP_ARGS )
    RESTIC_ARGS+=("${EXTRA_ARGS[@]}")
fi

RESTIC_BIN="${RESTIC_BIN:-restic}"

restic_backup() {
    "$RESTIC_BIN" backup "${RESTIC_ARGS[@]}"
}

restic_forget() {
    if [[ -n "$RESTIC_FORGET_ARGS" ]]; then
        "$RESTIC_BIN" forget $RESTIC_FORGET_ARGS
    fi
}

restic_check() {
    if [[ "${RESTIC_CHECK_AFTER_BACKUP:-0}" == "1" ]]; then
        "$RESTIC_BIN" check --read-data-subset=1/5
    fi
}

restic_backup
restic_forget
restic_check
EOS

cleanup_rc=$?

for f in "${cleanup[@]}"; do
    [[ -n "$f" ]] && rm -f "$f"
done

EVENT_RC=$cleanup_rc
if [[ $cleanup_rc -eq 0 ]]; then
    EVENT_STATUS="success"
    echo "[restic] manual backup completed at $(date +%Y%m%d_%H%M%S)"
else
    EVENT_STATUS="failure"
    echo "[restic] manual backup failed with rc=$cleanup_rc" >&2
fi

if [[ -f /opt/saltgoat-reactor/reactor_common.py ]]; then
    python3 - <<'PY'
import json
import os
import subprocess
import sys
from pathlib import Path

sys.path.insert(0, "/opt/saltgoat-reactor")
import reactor_common  # pylint: disable=import-error

REPO_ROOT = os.environ.get("SALTGOAT_REPO_ROOT")
if not REPO_ROOT:
    for candidate in (
        Path("/opt/saltgoat"),
        Path("/srv/saltgoat"),
        Path("/home/doge/saltgoat"),
        Path(__file__).resolve().parents[2] / "..",
    ):
        candidate = candidate.resolve()
        if (candidate / "modules" / "lib" / "notification.py").is_file():
            REPO_ROOT = str(candidate)
            break
if not REPO_ROOT:
    REPO_ROOT = str(Path(__file__).resolve().parents[2])
sys.path.insert(0, REPO_ROOT)
from modules.lib import notification as notif  # type: ignore

status = os.environ.get("EVENT_STATUS", "success")
repo = os.environ.get("RESTIC_REPOSITORY", "n/a")
site = os.environ.get("RESTIC_SITE", "")
log_file = os.environ.get("LOG_FILE", "")
tags = os.environ.get("RESTIC_TAGS", "")
rc = int(os.environ.get("EVENT_RC", "0") or 0)
host = os.environ.get("HOST_ID", "")
paths = []
include_file = os.environ.get("RESTIC_INCLUDE_FILE")
if include_file and os.path.isfile(include_file):
    with open(include_file, "r", encoding="utf-8") as fh:
        for line in fh:
            line = line.strip()
            if line:
                paths.append(line)

message_lines = [
    f"[SaltGoat] {'SUCCESS' if status == 'success' else 'FAILURE'} backup restic",
    f"Host: {host or 'ns510140'}",
    f"Repository/File: {repo or 'n/a'}",
]
if log_file:
    message_lines.append(f"Log: {log_file}")
if site:
    message_lines.append(f"Site: {site}")
if paths:
    message_lines.append(f"Paths: {', '.join(paths)}")
if tags:
    message_lines.append(f"Tags: {tags}")
message_lines.append(f"Return code: {rc}")
message = "\n".join(message_lines)
payload = {
    "severity": "INFO" if status == "success" else "ERROR",
    "site": site,
    "message": message,
}

LOG_PATH = "/var/log/saltgoat/alerts.log"
EVENT_TAG = f"saltgoat/backup/restic/{status}"
SITE_TAG = f"saltgoat/backup/restic/{site}" if site else None
TELEGRAM_TAG = SITE_TAG or EVENT_TAG
THREAD_ID = notif.get_thread_id(TELEGRAM_TAG) or notif.get_thread_id("saltgoat/backup/restic")

def log(label, payload):
    subprocess.run(
        [
            "python3",
            "/opt/saltgoat-reactor/logger.py",
            "TELEGRAM",
            LOG_PATH,
            f"{TELEGRAM_TAG} {label}",
            json.dumps(payload, ensure_ascii=False),
        ],
        check=False,
        timeout=5,
    )

profiles = reactor_common.load_telegram_profiles(None, log)
if not profiles:
    log("skip", {"reason": "no_profiles"})
    sys.exit(0)

try:
    log("profile_summary", {"count": len(profiles)})
    reactor_common.broadcast_telegram(
        message,
        profiles,
        log,
        tag=TELEGRAM_TAG,
        thread_id=THREAD_ID,
        parse_mode="HTML",
    )
except Exception as exc:  # pylint: disable=broad-except
    log("error", {"message": str(exc)})
    notif.queue_failure("telegram", TELEGRAM_TAG, {
        "severity": payload.get("severity", "INFO"),
        "site": site,
        "message": message,
    }, str(exc), {"thread": THREAD_ID})
PY
fi
