# Common helpers for SaltGoat reactor Python snippets.
import json
import os
import pathlib
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
from typing import Any, Dict, Iterable, List, Optional

try:
    import yaml  # type: ignore
except Exception:  # pragma: no cover
    yaml = None  # type: ignore

_SALT_SITE_ENV = os.environ.get("SALTGOAT_SALT_SITEPKG")
_SALT_SITE_CANDIDATES = [
    _SALT_SITE_ENV,
    "/opt/saltstack/salt/lib/python3.10/site-packages",
    "/usr/lib/python3/dist-packages",
]
for _candidate in _SALT_SITE_CANDIDATES:
    if not _candidate:
        continue
    _path = pathlib.Path(_candidate)
    if not _path.exists():
        continue
    if _candidate not in sys.path:
        sys.path.insert(0, _candidate)

try:
    import salt.client  # type: ignore
except Exception:  # pragma: no cover
    salt = None  # type: ignore

_CALLER = None
_REPO_ROOT: Optional[pathlib.Path] = None
_TOPIC_CACHE: Optional[Dict[str, Any]] = None


def _pillar_get(path: str, default: Any = None) -> Any:
    global _CALLER  # pylint: disable=global-statement
    if salt is None:  # type: ignore
        return default
    if _CALLER is None:
        try:
            _CALLER = salt.client.Caller()  # type: ignore
        except Exception:  # pragma: no cover
            _CALLER = None
            return default
    try:
        return _CALLER.cmd("pillar.get", path, default)  # type: ignore[union-attr]
    except Exception:  # pragma: no cover
        return default


def _discover_repo_root() -> Optional[pathlib.Path]:
    global _REPO_ROOT  # pylint: disable=global-statement
    if _REPO_ROOT is not None:
        return _REPO_ROOT
    candidates: List[pathlib.Path] = []
    env_root = os.environ.get("SALTGOAT_REPO_ROOT")
    if env_root:
        candidates.append(pathlib.Path(env_root))
    candidates.extend(
        [
            pathlib.Path("/opt/saltgoat"),
            pathlib.Path("/srv/saltgoat"),
            pathlib.Path("/home/doge/saltgoat"),
            pathlib.Path(__file__).resolve().parents[2],
            pathlib.Path(__file__).resolve().parents[2] / "..",
        ]
    )
    seen: set[pathlib.Path] = set()
    for candidate in candidates:
        try:
            resolved = candidate.resolve()
        except Exception:  # pragma: no cover
            continue
        if resolved in seen:
            continue
        seen.add(resolved)
        marker = resolved / "modules" / "lib" / "notification.py"
        if marker.is_file():
            _REPO_ROOT = resolved
            return _REPO_ROOT
    return None


def _load_yaml_dict(path: pathlib.Path) -> Dict[str, Any]:
    if yaml is None:
        return {}
    try:
        text = path.read_text(encoding="utf-8")
    except Exception:
        return {}
    try:
        data = yaml.safe_load(text) or {}
    except Exception:
        return {}
    if not isinstance(data, dict):
        return {}
    return data


def _load_local_telegram() -> Dict[str, Any]:
    root = _discover_repo_root()
    if root is None:
        return {}
    for rel in (
        "salt/pillar/secret/telegram.sls",
        "salt/pillar/telegram.sls",
    ):
        data = _load_yaml_dict(root / rel)
        if not data:
            continue
        if isinstance(data.get("telegram"), dict):
            return data["telegram"]
        if data.get("profiles"):
            return data
    return {}


def _load_local_topics() -> Dict[str, Any]:
    root = _discover_repo_root()
    if root is None:
        return {}
    for rel in (
        "salt/pillar/secret/telegram-topics.sls",
        "salt/pillar/telegram-topics.sls",
    ):
        data = _load_yaml_dict(root / rel)
        if not data:
            continue
        candidate: Optional[Dict[str, Any]] = None
        wrapper = data.get("telegram_topics")
        if isinstance(wrapper, dict):
            candidate = wrapper
        elif isinstance(data, dict):
            candidate = data
        if candidate:
            return candidate
    return {}


def _topic_cache_paths() -> List[pathlib.Path]:
    paths: List[pathlib.Path] = []
    env_path = os.environ.get("SALTGOAT_TOPIC_CACHE")
    if env_path:
        paths.append(pathlib.Path(env_path))
    paths.append(pathlib.Path("/var/lib/saltgoat/telegram-topics.json"))
    try:
        home = pathlib.Path.home()
    except Exception:  # pragma: no cover
        home = None
    if home is not None:
        paths.append(home / ".saltgoat" / "telegram-topics.json")
    return paths


def _load_topic_cache() -> Dict[str, Any]:
    global _TOPIC_CACHE  # pylint: disable=global-statement
    if _TOPIC_CACHE is not None:
        return _TOPIC_CACHE
    merged: Dict[str, Any] = {"entries": {}}
    for path in _topic_cache_paths():
        try:
            text = path.read_text(encoding="utf-8")
        except Exception:
            continue
        try:
            data = json.loads(text)
        except Exception:
            continue
        if isinstance(data, dict):
            entries = data.get("entries") if isinstance(data.get("entries"), dict) else None
            if entries is None and all(isinstance(v, dict) for v in data.values()):
                entries = data
            if isinstance(entries, dict):
                merged["entries"].update(entries)
    _TOPIC_CACHE = merged
    return _TOPIC_CACHE


def _save_topic_cache() -> None:
    cache = _load_topic_cache()
    for path in _topic_cache_paths():
        try:
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(json.dumps(cache, ensure_ascii=False, indent=2), encoding="utf-8")
        except Exception:
            continue
        else:
            break


def _topic_cache_key(chat_id: str, title: str) -> str:
    return f"{chat_id.strip()}::{title.strip()}".lower()


def _topic_cache_lookup(chat_id: str, title: str) -> Optional[int]:
    cache = _load_topic_cache()
    entry = cache.get("entries", {}).get(_topic_cache_key(chat_id, title))
    if isinstance(entry, dict):
        thread = entry.get("thread_id")
        if isinstance(thread, int):
            return thread
        try:
            return int(str(thread))
        except Exception:
            return None
    return None


def _topic_cache_store(chat_id: str, title: str, thread_id: int) -> None:
    cache = _load_topic_cache()
    cache.setdefault("entries", {})[_topic_cache_key(chat_id, title)] = {
        "chat_id": chat_id,
        "title": title,
        "thread_id": int(thread_id),
        "updated": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    }
    _save_topic_cache()


def _ensure_list(value: Any) -> List[Any]:
    if isinstance(value, (list, tuple, set)):
        return [item for item in value if item not in (None, "")]
    if value not in (None, ""):
        return [value]
    return []


def _normalize_target(target: Any) -> Optional[Dict[str, Any]]:
    if isinstance(target, dict):
        chat_id = target.get("chat_id") or target.get("id") or target.get("chat")
        if chat_id in (None, ""):
            return None
        normalized: Dict[str, Any] = {"chat_id": str(chat_id)}
        thread = target.get("thread_id") or target.get("thread")
        if thread not in (None, "", 0, "0"):
            try:
                normalized["thread_id"] = int(thread)
            except Exception:  # pylint: disable=broad-except
                normalized["thread_id"] = thread
        return normalized
    if target in (None, ""):
        return None
    return {"chat_id": str(target)}


def _normalize_topics(topics: Any) -> Dict[str, Any]:
    if not isinstance(topics, dict):
        return {}
    result: Dict[str, Any] = {}
    for key, value in topics.items():
        if key in (None, ""):
            continue
        if isinstance(value, dict):
            result[str(key)] = value
            continue
        thread = _extract_thread_id(value)
        if thread is not None:
            result[str(key)] = thread
    return result


def _extract_thread_id(value: Any) -> Optional[int]:
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        try:
            return int(value.strip())
        except Exception:  # pragma: no cover
            return None
    if isinstance(value, dict):
        for key in ("thread_id", "topic_id", "id"):
            candidate = value.get(key)
            if candidate in (None, ""):
                continue
            try:
                return int(candidate)
            except Exception:
                continue
    return None


def _create_forum_topic(token: str, chat_id: str, title: str, icon_color: Optional[Any] = None, icon_custom_emoji_id: Optional[Any] = None, log=None) -> Optional[int]:
    payload: Dict[str, Any] = {"chat_id": chat_id, "name": title}
    if icon_color not in (None, ""):
        try:
            payload["icon_color"] = int(icon_color)
        except Exception:
            pass
    if icon_custom_emoji_id not in (None, ""):
        payload["icon_custom_emoji_id"] = str(icon_custom_emoji_id)
    data = urllib.parse.urlencode(payload).encode()
    url = f"https://api.telegram.org/bot{token}/createForumTopic"
    req = urllib.request.Request(url, data=data)
    error_desc: Optional[str] = None
    try:
        with urllib.request.urlopen(req, timeout=15) as resp:
            raw = resp.read()
    except urllib.error.HTTPError as exc:  # pragma: no cover
        try:
            raw = exc.read()
            error_desc = raw.decode("utf-8", errors="ignore") or str(exc)
        except Exception:
            raw = b"{}"
            error_desc = str(exc)
    except Exception as exc:  # pragma: no cover
        if log:
            log("topic_create_failed", {"chat": chat_id, "title": title, "error": str(exc)})
        return None
    try:
        response = json.loads(raw or b"{}")
    except Exception:
        response = {}
    if not response.get("ok"):
        if log:
            log("topic_create_failed", {"chat": chat_id, "title": title, "error": error_desc or response.get("description")})
        return None
    result = response.get("result")
    if not isinstance(result, dict):
        return None
    thread = result.get("message_thread_id")
    if thread in (None, "", 0, "0"):
        return None
    try:
        return int(thread)
    except Exception:
        return None


def _ensure_topic_thread(value: Dict[str, Any], token: str, chat: str, log=None) -> Optional[int]:
    title = value.get("title") or value.get("topic") or value.get("name")
    chat_id = value.get("chat_id") or chat
    if not title or not chat_id:
        return None
    chat_id = str(chat_id)
    cached = _topic_cache_lookup(chat_id, title)
    if cached:
        return cached
    thread = _create_forum_topic(token, chat_id, title, value.get("icon_color"), value.get("icon_custom_emoji_id"), log)
    if thread:
        _topic_cache_store(chat_id, title, thread)
        return thread
    return None


def _resolve_topic_value(value: Any, token: str, chat: str, log=None) -> Optional[int]:
    thread = _extract_thread_id(value)
    if thread is not None:
        return thread
    if isinstance(value, dict):
        thread = _ensure_topic_thread(value, token, chat, log)
        if thread is not None:
            value.setdefault("thread_id", thread)
            return thread
    return None


def _resolve_topic(tag: Optional[str], topics: Dict[str, Any]) -> Optional[Any]:
    if not tag or not topics:
        return None
    candidates = sorted(topics.keys(), key=len, reverse=True)
    for key in candidates:
        if tag == key or tag.startswith(f"{key}/"):
            return topics[key]
    return topics.get("*")


def _load_profiles_from_pillar(log=None) -> List[Dict[str, Any]]:
    telegram = _pillar_get("telegram", {}) or {}
    if not isinstance(telegram, dict):
        telegram = {}
    if not telegram.get("profiles"):
        fallback = _load_local_telegram()
        if fallback:
            telegram = fallback
        elif log:
            log("pillar_missing", {"path": "telegram"})
            return []
    profiles_cfg = telegram.get("profiles")
    if not isinstance(profiles_cfg, dict):
        fallback = _load_local_telegram()
        if isinstance(fallback.get("profiles"), dict):
            profiles_cfg = fallback["profiles"]
        elif log:
            log("profiles_missing", {"path": "telegram:profiles"})
            return []
    topics_raw = _pillar_get("telegram_topics", {}) or {}
    if not isinstance(topics_raw, dict) or not topics_raw:
        topics_raw = _load_local_topics()
    global_topics = _normalize_topics(topics_raw)
    profiles: List[Dict[str, Any]] = []
    for name, entry in profiles_cfg.items():
        if not isinstance(entry, dict):
            continue
        if not entry.get("enabled", True):
            continue
        token = entry.get("token")
        if not token:
            continue
        ordered_targets: List[Any] = []
        for key in ("targets", "chat_ids", "accept_from", "chat_id"):
            for item in _ensure_list(entry.get(key)):
                if item not in ordered_targets:
                    ordered_targets.append(item)
        targets_normalized = []
        for target in ordered_targets:
            normalized = _normalize_target(target)
            if normalized and normalized not in targets_normalized:
                targets_normalized.append(normalized)
        if not targets_normalized:
            continue
        specific_topics = _normalize_topics(entry.get("threads"))
        combined_topics = dict(global_topics)
        combined_topics.update(specific_topics)
        profiles.append(
            {
                "name": name or f"profile{len(profiles) + 1}",
                "token": token,
                "targets": targets_normalized,
                "topics": combined_topics,
            }
        )
    if not profiles and log:
        log("profiles_empty", {"path": "telegram:profiles"})
    return profiles


def load_telegram_profiles(_config_path: Optional[str] = None, log=None) -> List[Dict[str, Any]]:
    return _load_profiles_from_pillar(log)


def broadcast_telegram(
    message: str,
    profiles: List[Dict[str, Any]],
    log=None,
    tag: Optional[str] = None,
    thread_id: Optional[Any] = None,
    parse_mode: Optional[str] = None,
) -> None:
    if not message or not profiles:
        if log and not message:
            log("skip", {"reason": "empty_message"})
        return
    if log:
        log("profile_summary", {"count": len(profiles)})

    for profile in profiles:
        token = profile.get("token")
        targets = profile.get("targets") or []
        name = profile.get("name", "profile")
        topics = profile.get("topics") or {}
        if not token or not targets:
            if log:
                log("skip", {"reason": "profile_missing", "profile": name})
            continue
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        for target in targets:
            if isinstance(target, dict):
                chat = target.get("chat_id")
            else:
                chat = target
            if chat in (None, ""):
                continue
            effective_thread = thread_id
            if effective_thread in (None, "", 0, "0") and isinstance(target, dict):
                effective_thread = target.get("thread_id")
            if effective_thread in (None, "", 0, "0"):
                resolved = _resolve_topic(tag, topics)
                candidate = _resolve_topic_value(resolved, token, str(chat), log)
                if candidate not in (None, "", 0, "0"):
                    effective_thread = candidate
            params = {
                "chat_id": str(chat),
                "text": message,
                "disable_web_page_preview": True,
            }
            if parse_mode:
                params["parse_mode"] = parse_mode
            if effective_thread not in (None, "", 0, "0"):
                params["message_thread_id"] = str(effective_thread)
            data = urllib.parse.urlencode(params).encode()
            req = urllib.request.Request(url, data=data)
            if log:
                log(
                    "send_attempt",
                    {
                        "profile": name,
                        "chat": chat,
                        "thread_id": params.get("message_thread_id"),
                        "tag": tag,
                    },
                )
            try:
                with urllib.request.urlopen(req, timeout=15):
                    pass
            except Exception as exc:  # pylint: disable=broad-except
                if log:
                    log(
                        "send_failed",
                        {
                            "profile": name,
                            "chat": chat,
                            "thread_id": params.get("message_thread_id"),
                            "tag": tag,
                            "error": str(exc),
                        },
                    )
            else:
                if log:
                    log(
                        "send_ok",
                        {
                            "profile": name,
                            "chat": chat,
                            "thread_id": params.get("message_thread_id"),
                            "tag": tag,
                        },
                    )
