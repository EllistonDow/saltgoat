# Common helpers for SaltGoat reactor Python snippets.
import os
import pathlib
import sys
import urllib.parse
import urllib.request
from typing import Any, Dict, Iterable, List, Optional

try:
    import yaml  # type: ignore
except Exception:  # pragma: no cover
    yaml = None  # type: ignore

_SALT_SITE_ENV = os.environ.get("SALTGOAT_SALT_SITEPKG")
_SALT_SITE_CANDIDATES = [
    _SALT_SITE_ENV,
    "/opt/saltstack/salt/lib/python3.10/site-packages",
    "/usr/lib/python3/dist-packages",
]
for _candidate in _SALT_SITE_CANDIDATES:
    if not _candidate:
        continue
    _path = pathlib.Path(_candidate)
    if not _path.exists():
        continue
    if _candidate not in sys.path:
        sys.path.insert(0, _candidate)

try:
    import salt.client  # type: ignore
except Exception:  # pragma: no cover
    salt = None  # type: ignore

_CALLER = None
_REPO_ROOT: Optional[pathlib.Path] = None


def _pillar_get(path: str, default: Any = None) -> Any:
    global _CALLER  # pylint: disable=global-statement
    if salt is None:  # type: ignore
        return default
    if _CALLER is None:
        try:
            _CALLER = salt.client.Caller()  # type: ignore
        except Exception:  # pragma: no cover
            _CALLER = None
            return default
    try:
        return _CALLER.cmd("pillar.get", path, default)  # type: ignore[union-attr]
    except Exception:  # pragma: no cover
        return default


def _discover_repo_root() -> Optional[pathlib.Path]:
    global _REPO_ROOT  # pylint: disable=global-statement
    if _REPO_ROOT is not None:
        return _REPO_ROOT
    candidates: List[pathlib.Path] = []
    env_root = os.environ.get("SALTGOAT_REPO_ROOT")
    if env_root:
        candidates.append(pathlib.Path(env_root))
    candidates.extend(
        [
            pathlib.Path("/opt/saltgoat"),
            pathlib.Path("/srv/saltgoat"),
            pathlib.Path("/home/doge/saltgoat"),
            pathlib.Path(__file__).resolve().parents[2],
            pathlib.Path(__file__).resolve().parents[2] / "..",
        ]
    )
    seen: set[pathlib.Path] = set()
    for candidate in candidates:
        try:
            resolved = candidate.resolve()
        except Exception:  # pragma: no cover
            continue
        if resolved in seen:
            continue
        seen.add(resolved)
        marker = resolved / "modules" / "lib" / "notification.py"
        if marker.is_file():
            _REPO_ROOT = resolved
            return _REPO_ROOT
    return None


def _load_yaml_dict(path: pathlib.Path) -> Dict[str, Any]:
    if yaml is None:
        return {}
    try:
        text = path.read_text(encoding="utf-8")
    except Exception:
        return {}
    try:
        data = yaml.safe_load(text) or {}
    except Exception:
        return {}
    if not isinstance(data, dict):
        return {}
    return data


def _load_local_telegram() -> Dict[str, Any]:
    root = _discover_repo_root()
    if root is None:
        return {}
    for rel in (
        "salt/pillar/secret/telegram.sls",
        "salt/pillar/telegram.sls",
    ):
        data = _load_yaml_dict(root / rel)
        if not data:
            continue
        if isinstance(data.get("telegram"), dict):
            return data["telegram"]
        if data.get("profiles"):
            return data
    return {}


def _load_local_topics() -> Dict[str, Any]:
    root = _discover_repo_root()
    if root is None:
        return {}
    for rel in (
        "salt/pillar/secret/telegram-topics.sls",
        "salt/pillar/telegram-topics.sls",
    ):
        data = _load_yaml_dict(root / rel)
        if not data:
            continue
        candidate: Optional[Dict[str, Any]] = None
        wrapper = data.get("telegram_topics")
        if isinstance(wrapper, dict):
            candidate = wrapper
        elif isinstance(data, dict):
            candidate = data
        if candidate:
            return candidate
    return {}


def _ensure_list(value: Any) -> List[Any]:
    if isinstance(value, (list, tuple, set)):
        return [item for item in value if item not in (None, "")]
    if value not in (None, ""):
        return [value]
    return []


def _normalize_target(target: Any) -> Optional[Dict[str, Any]]:
    if isinstance(target, dict):
        chat_id = target.get("chat_id") or target.get("id") or target.get("chat")
        if chat_id in (None, ""):
            return None
        normalized: Dict[str, Any] = {"chat_id": str(chat_id)}
        thread = target.get("thread_id") or target.get("thread")
        if thread not in (None, "", 0, "0"):
            try:
                normalized["thread_id"] = int(thread)
            except Exception:  # pylint: disable=broad-except
                normalized["thread_id"] = thread
        return normalized
    if target in (None, ""):
        return None
    return {"chat_id": str(target)}


def _normalize_topics(topics: Any) -> Dict[str, Any]:
    if not isinstance(topics, dict):
        return {}
    result: Dict[str, Any] = {}
    for key, value in topics.items():
        if key in (None, ""):
            continue
        thread = value
        if thread in (None, "", 0, "0"):
            continue
        try:
            result[str(key)] = int(thread)
        except Exception:  # pylint: disable=broad-except
            result[str(key)] = thread
    return result


def _resolve_topic(tag: Optional[str], topics: Dict[str, Any]) -> Optional[Any]:
    if not tag or not topics:
        return None
    candidates = sorted(topics.keys(), key=len, reverse=True)
    for key in candidates:
        if tag == key or tag.startswith(f"{key}/"):
            return topics[key]
    return topics.get("*")


def _load_profiles_from_pillar(log=None) -> List[Dict[str, Any]]:
    telegram = _pillar_get("telegram", {}) or {}
    if not isinstance(telegram, dict):
        telegram = {}
    if not telegram.get("profiles"):
        fallback = _load_local_telegram()
        if fallback:
            telegram = fallback
        elif log:
            log("pillar_missing", {"path": "telegram"})
            return []
    profiles_cfg = telegram.get("profiles")
    if not isinstance(profiles_cfg, dict):
        fallback = _load_local_telegram()
        if isinstance(fallback.get("profiles"), dict):
            profiles_cfg = fallback["profiles"]
        elif log:
            log("profiles_missing", {"path": "telegram:profiles"})
            return []
    topics_raw = _pillar_get("telegram_topics", {}) or {}
    if not isinstance(topics_raw, dict) or not topics_raw:
        topics_raw = _load_local_topics()
    global_topics = _normalize_topics(topics_raw)
    profiles: List[Dict[str, Any]] = []
    for name, entry in profiles_cfg.items():
        if not isinstance(entry, dict):
            continue
        if not entry.get("enabled", True):
            continue
        token = entry.get("token")
        if not token:
            continue
        ordered_targets: List[Any] = []
        for key in ("targets", "chat_ids", "accept_from", "chat_id"):
            for item in _ensure_list(entry.get(key)):
                if item not in ordered_targets:
                    ordered_targets.append(item)
        targets_normalized = []
        for target in ordered_targets:
            normalized = _normalize_target(target)
            if normalized and normalized not in targets_normalized:
                targets_normalized.append(normalized)
        if not targets_normalized:
            continue
        specific_topics = _normalize_topics(entry.get("threads"))
        combined_topics = dict(global_topics)
        combined_topics.update(specific_topics)
        profiles.append(
            {
                "name": name or f"profile{len(profiles) + 1}",
                "token": token,
                "targets": targets_normalized,
                "topics": combined_topics,
            }
        )
    if not profiles and log:
        log("profiles_empty", {"path": "telegram:profiles"})
    return profiles


def load_telegram_profiles(_config_path: Optional[str] = None, log=None) -> List[Dict[str, Any]]:
    return _load_profiles_from_pillar(log)


def broadcast_telegram(
    message: str,
    profiles: List[Dict[str, Any]],
    log=None,
    tag: Optional[str] = None,
    thread_id: Optional[Any] = None,
    parse_mode: Optional[str] = None,
) -> None:
    if not message or not profiles:
        if log and not message:
            log("skip", {"reason": "empty_message"})
        return
    if log:
        log("profile_summary", {"count": len(profiles)})

    for profile in profiles:
        token = profile.get("token")
        targets = profile.get("targets") or []
        name = profile.get("name", "profile")
        topics = profile.get("topics") or {}
        if not token or not targets:
            if log:
                log("skip", {"reason": "profile_missing", "profile": name})
            continue
        url = f"https://api.telegram.org/bot{token}/sendMessage"
        for target in targets:
            if isinstance(target, dict):
                chat = target.get("chat_id")
            else:
                chat = target
            if chat in (None, ""):
                continue
            effective_thread = thread_id
            if effective_thread in (None, "", 0, "0") and isinstance(target, dict):
                effective_thread = target.get("thread_id")
            if effective_thread in (None, "", 0, "0"):
                resolved = _resolve_topic(tag, topics)
                if resolved not in (None, "", 0, "0"):
                    effective_thread = resolved
            params = {
                "chat_id": str(chat),
                "text": message,
                "disable_web_page_preview": True,
            }
            if parse_mode:
                params["parse_mode"] = parse_mode
            if effective_thread not in (None, "", 0, "0"):
                params["message_thread_id"] = str(effective_thread)
            data = urllib.parse.urlencode(params).encode()
            req = urllib.request.Request(url, data=data)
            if log:
                log(
                    "send_attempt",
                    {
                        "profile": name,
                        "chat": chat,
                        "thread_id": params.get("message_thread_id"),
                        "tag": tag,
                    },
                )
            try:
                with urllib.request.urlopen(req, timeout=15):
                    pass
            except Exception as exc:  # pylint: disable=broad-except
                if log:
                    log(
                        "send_failed",
                        {
                            "profile": name,
                            "chat": chat,
                            "thread_id": params.get("message_thread_id"),
                            "tag": tag,
                            "error": str(exc),
                        },
                    )
            else:
                if log:
                    log(
                        "send_ok",
                        {
                            "profile": name,
                            "chat": chat,
                            "thread_id": params.get("message_thread_id"),
                            "tag": tag,
                        },
                    )
